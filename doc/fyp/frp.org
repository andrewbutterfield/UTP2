* Functional Reactive Programming
The application will in some places refer to some data which will change over
time, due to user input or for other reasons. For example, on the home screen we
display the current workspace directory, however the current workspace may be
changed by the user. Updating elements to reflect changes in their dependant
data can be done in two ways. First, on change of the data we can update each
element which uses that data, this is the imperative way of doing things.
Second, we can define any element which uses the data to *react* to changes in
the data.

#+BEGIN_SRC haskell
text <- UI.div # set UI.text "I want to display the current workspace"
#+END_SRC

#+BEGIN_SRC haskell
on UI.valuechange selector $ const $ do
  -- The current workspace has changed.
#+END_SRC

The downside of the first approach is that when we write some new element that
depends on the data we have to remember to write code that will update the
element whenever the data changes. The code to display the element and the
code which executes on change of the data may be in separate modules, or at
least separate to some degree. Thus the fact that we have to consider the
concerns of some element which uses our data, on change of that data, is a
violation of the separation of concerns principle. Furtheremore, this code
which deals with the change of the data will need to have references to the
elements it's expected to update, these would need to be passed either as
parameters or monadically, which is unecessary overhead.

** TODO How the second approach works.

The benefit of the second approach is that when we write the code which executes
on change of the data, we don't have to worry about all the elements in our
codebase which depend on said data, or worry about getting the references to
these elements. We are also no longer violating the separation of concerns
principle.
  
